unit CFX.Types;

interface
  uses
    UITypes, Types, CFX.UIConsts, VCl.GraphUtil, Winapi.Windows,
    Classes, Vcl.Themes, Vcl.Controls, Vcl.Graphics,
    CFX.Classes, CFX.Colors, SysUtils, GDIPAPI, GDIPOBJ;

  type
    // Cardinals
    TFileType = (dftText, dftBMP, dftPNG, dftJPEG, dftGIF, dftHEIC, dftTIFF,
      dftMP3, dftMP4, dftFlac, dftMDI, dftOGG, dftSND, dftM3U8, dftEXE, dftMSI,
      dftZip, dftGZip, dft7Zip, dftCabinet, dftTAR, dftRAR, dftLZIP, dftISO,
      dftPDF, dftHLP, dftCHM);

    FXImageType = (fitImage, fitBitMap, fitImageList, fitSegoeIcon);

    // Classes
    FXIconSelect = class(TObject)
    private
      FEnabled: boolean;

      FType: FXImageType;
      FPicture: TPicture;
      FBitMap: TBitMap;
      FSegoeText: string;
      FImageIndex: integer;

      procedure SetBitMap(const Value: TBitMap);
      procedure SetPicture(const Value: TPicture);

    published
      property Enabled: boolean read FEnabled write FEnabled;
      property IconType: FXImageType read FType write FType;

      property SelectPicture: TPicture read FPicture write SetPicture;
      property SelectBitmap: TBitMap read FBitMap write SetBitMap;
      property SelectSegoe: string read FSegoeText write FSegoeText;
      property SelectImageIndex: integer read FImageIndex write FImageIndex;

    public
      constructor Create;
      destructor Destroy; override;

      procedure FreeUnusedAssets;
    end;

    FXRGBA = record
    public
      R, G, B, A: byte;

      function Create(Red, Green, Blue: Byte; Alpha: Byte = 255): FXRGBA;

      function MakeGDIBrush: TGPSolidBrush;
      function MakeGDIPen(Width: Single = 1): TGPPen;

      function ToColor(Alpha: Byte = 255): TColor;
      procedure FromColor(Color: TColor; Alpha: Byte = 255);
    end;

  { Color Conversion }
  function GetRGB(Color: TColor; Alpha: Byte = 255): FXRGBA; overload;
  function GetRGB(R, G, B: Byte; Alpha: Byte = 255): FXRGBA; overload;

  { Rectangles }
  function GetValidRect(Point1, Point2: TPoint): TRect; overload;
  function GetValidRect(Points: TArray<TPoint>): TRect; overload;
  function GetValidRect(Rect: TRect): TRect; overload;

  { Conversion }
  function DecToHex(Dec: int64): string;

implementation

function GetRGB(Color: TColor; Alpha: Byte): FXRGBA;
begin
  Result.FromColor(Color, Alpha);
end;

function GetRGB(R, G, B: Byte; Alpha: Byte): FXRGBA;
begin
  Result.Create(R, G, B, Alpha);
end;

function GetValidRect(Point1, Point2: TPoint): TRect;
begin
  if Point1.X < Point2.X then
    Result.Left := Point1.X
  else
    Result.Left := Point2.X;

  if Point1.Y < Point2.Y then
    Result.Top := Point1.Y
  else
    Result.Top := Point2.Y;

  Result.Width := abs( Point2.X - Point1.X);
  Result.Height := abs( Point2.Y - Point1.Y);
end;

function GetValidRect(Points: TArray<TPoint>): TRect; overload
var
  I: Integer;
begin
  if Length( Points ) = 0 then
    Exit;

  Result.TopLeft := Points[0];
  Result.BottomRight := Points[0];

  for I := 1 to High(Points) do
    begin
      if Points[I].X < Result.Left then
        Result.Left := Points[I].X;
      if Points[I].Y < Result.Top then
        Result.Top := Points[I].Y;

      if Points[I].X > Result.Right then
        Result.Right := Points[I].X;
      if Points[I].Y > Result.Bottom then
        Result.Bottom := Points[I].Y;
    end;
end;

function GetValidRect(Rect: TRect): TRect;
begin
  if Rect.TopLeft.X < Rect.BottomRight.X then
    Result.Left := Rect.TopLeft.X
  else
    Result.Left := Rect.BottomRight.X;

  if Rect.TopLeft.Y < Rect.BottomRight.Y then
    Result.Top := Rect.TopLeft.Y
  else
    Result.Top := Rect.BottomRight.Y;

  Result.Width := abs( Rect.BottomRight.X - Rect.TopLeft.X);
  Result.Height := abs( Rect.BottomRight.Y - Rect.TopLeft.Y);
end;

function DecToHex(Dec: int64): string;
var
  I: Integer;
begin
  //result:= digits[Dec shr 4]+digits[Dec and $0F];
  Result := IntToHex(Dec);

  for I := 1 to length(Result) do
      if (Result[1] = '0') and (Length(Result) > 2) then
        Result := Result.Remove(0, 1)
      else
        Break;

  if Result = '' then
        Result := '00';
end;

{ FXRGBA }

function FXRGBA.Create(Red, Green, Blue, Alpha: Byte): FXRGBA;
begin
  R := Red;
  G := Green;
  B := Blue;

  A := Alpha;

  Result := Self;
end;

procedure FXRGBA.FromColor(Color: TColor; Alpha: Byte);
var
  RBGval: longint;
begin
  RBGval := ColorToRGB(Color);

  try
    R := GetRValue(RBGval);
    G := GetGValue(RBGval);
    B := GetBValue(RBGval);

    A := Alpha;
  finally

  end;
end;

function FXRGBA.MakeGDIBrush: TGPSolidBrush;
begin
  Result := TGPSolidBrush.Create( MakeColor(A, R, G, B) );
end;

function FXRGBA.MakeGDIPen(Width: Single): TGPPen;
begin
  Result := TGPPen.Create( MakeColor(A, R, G, B), Width );
end;

function FXRGBA.ToColor(Alpha: Byte): TColor;
begin
  Result := RGB(R, G, B);

  A := Alpha;
end;

{ FXIconSelect }

constructor FXIconSelect.Create;
begin
  Enabled := false;

  IconType := fitSegoeIcon;
  FSegoeText := SEGOE_UI_STAR;
end;

destructor FXIconSelect.Destroy;
begin

  inherited;
end;

procedure FXIconSelect.FreeUnusedAssets;
begin
  if (IconType <> fitImage) and (FPicture <> nil) and (not FPicture.Graphic.Empty) then
    FPicture.Free;

  if (IconType <> fitBitMap) and (FBitMap <> nil) and (not FBitMap.Empty) then
    FBitMap.Free;
end;

procedure FXIconSelect.SetBitMap(const Value: TBitMap);
begin
  FBitmap.Assign(value);
end;

procedure FXIconSelect.SetPicture(const Value: TPicture);
begin
  FPicture.Assign(Value);
end;

end.
